//! Controls the playing of music as the player explores the universe

use std::{fs, time::Duration};

use bevy::{
    app::Update,
    asset::{AssetServer, Handle},
    log::{error, warn},
    prelude::{not, on_event, resource_exists, App, Commands, EventReader, EventWriter, IntoSystemConfigs, OnEnter, Res, ResMut, Resource},
    time::Time,
};
use bevy_kira_audio::{Audio, AudioControl, AudioEasing, AudioSource, AudioTween};
use cosmos_core::{state::GameState, utils::random::random_range};
use rand::seq::IteratorRandom;
use serde::{Deserialize, Serialize};

use super::{PlayMusicEvent, PlayingBackgroundSong, VolumeSetting};

#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Serialize, Deserialize)]
/// Describes the "Atmosphere"/mood the music should be played in.
pub enum MusicAtmosphere {
    /// A calm environment, such as peacefully flying around or walking on a planet
    Calm,
    /// Intense action, such as being in combat
    Intense,
}

#[derive(Clone, PartialEq, Eq, Debug)]
/// A song that plays in the background.
///
/// These are automatically generated by looking in the `assets/cosmos/sounds/music` directory.
/// Make sure each `.ogg` file has a `.json` file with the same name that specifies its metadata.
pub struct BackgroundSong {
    atmosphere: MusicAtmosphere,
    handle: Handle<AudioSource>,
}

#[derive(Default, Debug, Resource)]
/// Contains the music the game can play
pub struct MusicController {
    songs: Vec<BackgroundSong>,
}

impl MusicController {
    /// Adds a song that can be played
    pub fn add_song(&mut self, song: BackgroundSong) {
        self.songs.push(song);
    }

    /// Selects a random song that matches this atmosphere
    pub fn random_song(&self, atmosphere: MusicAtmosphere) -> Option<&BackgroundSong> {
        self.songs
            .iter()
            .filter(|x| x.atmosphere == atmosphere)
            .choose(&mut rand::thread_rng())
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct MusicDefinition {
    atmosphere: MusicAtmosphere,
}

fn load_default_songs(asset_server: Res<AssetServer>, mut music_controller: ResMut<MusicController>) {
    let Ok(entries) = fs::read_dir("assets/cosmos/sounds/music/") else {
        error!("Missing music directory - unable to load background music!");
        return;
    };

    for entry in entries {
        match entry {
            Ok(entry) => {
                let path = entry.path();
                let Some(extension) = path.extension() else {
                    continue;
                };
                if extension.to_ascii_lowercase() != "ogg" {
                    continue;
                }

                let def_path = path.with_extension("json");
                let Ok(info_file) = fs::read_to_string(&def_path) else {
                    error!("Missing music info file for {path:?}");
                    continue;
                };

                let Ok(music_def) = serde_json::from_str::<MusicDefinition>(&info_file) else {
                    error!("Invalid music definition file for {:?}", def_path);
                    continue;
                };

                let song = BackgroundSong {
                    atmosphere: music_def.atmosphere,
                    handle: asset_server.load(format!("cosmos/sounds/music/{}", path.file_name().expect("How?").to_str().unwrap())),
                };

                music_controller.add_song(song);
            }
            Err(e) => {
                error!("{e:?}");
            }
        }
    }
}

fn start_playing(
    mut commands: Commands,
    mut evr_play_music: EventReader<PlayMusicEvent>,
    audio: Res<Audio>,
    volume: Res<VolumeSetting>,
    jukebox: Res<MusicController>,
) {
    let Some(ev) = evr_play_music.read().next() else {
        return;
    };

    let Some(song) = jukebox.random_song(ev.atmosphere) else {
        warn!("Missing song for atmosphere: {:?}", ev.atmosphere);
        return;
    };

    let handle = audio
        .play(song.handle.clone())
        .with_volume(volume.percent())
        .fade_in(AudioTween::new(Duration::from_secs(2), AudioEasing::InOutPowi(2)))
        .handle();

    commands.insert_resource(PlayingBackgroundSong(handle));
}

#[derive(Resource, Debug)]
struct NextSongTime(f32);

fn trigger_music_playing(mut next_song_time: ResMut<NextSongTime>, mut event_writer: EventWriter<PlayMusicEvent>, time: Res<Time>) {
    const MIN_DELAY_SEC: f32 = 5.0 * 60.0; // 5min
    const MAX_DELAY_SEC: f32 = 20.0 * 60.0; // 20min

    if next_song_time.0 > time.elapsed_seconds() {
        return;
    }

    next_song_time.0 = time.elapsed_seconds() + random_range(MIN_DELAY_SEC, MAX_DELAY_SEC);

    event_writer.send(PlayMusicEvent {
        atmosphere: MusicAtmosphere::Calm,
    });
}

pub(super) fn register(app: &mut App) {
    app.init_resource::<MusicController>().insert_resource(NextSongTime(0.0));

    app.add_systems(OnEnter(GameState::Loading), load_default_songs);

    app.add_systems(
        Update,
        (trigger_music_playing, start_playing.run_if(on_event::<PlayMusicEvent>()))
            .chain()
            .run_if(not(resource_exists::<PlayingBackgroundSong>))
            .run_if(resource_exists::<MusicController>),
    );
}
